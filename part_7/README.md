网络
-----

### 区块链网络特点
1. 区块链网络是去中心化的，这意味着没有服务器。客户端也不需要依赖服务器来获取或处理数据。
2. 在区块链网络中，每个节点是网络的一个完全（full-fledged）成员
3. 节点就是一切：它既是一个客户端，也是一个服务器
4. 节点直接连接到其他节点，它的拓扑是扁平的。


### 比特币网络节点的角色
尽管节点具有完备成熟的属性，但是它们也可以在网络中扮演不同角色

##### 矿工
这样的节点运行于强大或专用的硬件（比如 ASIC）之上，它们唯一的目标是，尽可能快地挖出新块。矿工是区块链中唯一可能会用到工作量证明的角色，因为挖矿实际上意味着解决 PoW 难题。在权益证明 PoS 的区块链中，没有挖矿

##### 全节点
这些节点验证矿工挖出来的块的有效性，并对交易进行确认。为此，他们必须拥有区块链的完整拷贝。同时，全节点执行路由操作，帮助其他节点发现彼此。对于网络来说，非常重要的一段就是要有足够多的全节点。因为正是这些节点执行了决策功能：他们决定了一个块或一笔交易的有效性.

##### SPV -- Simplified Payment Verification
简单支付验证。这些节点并不存储整个区块链副本，但是仍然能够对交易进行验证（不过不是验证全部交易，而是一个交易子集，比如，发送到某个指定地址的交易）。一个 SPV 节点依赖一个全节点来获取数据，可能有多个 SPV 节点连接到一个全节点。SPV 使得钱包应用成为可能：一个人不需要下载整个区块链，但是仍能够验证他的交易。


### 简单实现

在 Bitcoin Core 中，硬编码了 DNS seeds。虽然这些并不是节点，但是 DNS 服务器知道一些节点的地址。当你启动一个全新的 Bitcoin Core 时，它会连接到一个种子节点，获取全节点列表，随后从这些节点中下载区块链。<br/>

##### 节点实现
我们没有那么多的计算机来模拟一个多节点的网络，所以，我们想要在一台机器上运行多个区块链节点，同时希望它们有不同的地址。为了实现这一点，我们将使用端口号作为节点标识符，而不是使用 IP 地址，比如将会有这样地址的节点：127.0.0.1:3000，127.0.0.1:3001，127.0.0.1:3002 等等。我们叫它端口节点（port node） ID，并使用环境变量 NODE_ID 对它们进行设置。故而，你可以打开多个终端窗口，设置不同的 NODE_ID 运行不同的节点。

##### 节点角色
在我们目前的实现中，无法做到完全的去中心化，因为会出现中心化的特点。我们会有三个节点：
1. 一个中心节点。所有其他节点都会连接到这个节点，这个节点会在其他节点之间发送数据。
2. 一个矿工节点。这个节点会在内存池中存储新的交易，当有足够的交易时，它就会打包挖出一个新块。
3. 一个钱包节点。这个节点会被用作在钱包之间发送币。但是与 SPV 节点不同，它存储了区块链的一个完整副本。

### 要实现的场景
1. 中心节点创建一个区块链。
2. 一个其他（钱包）节点连接到中心节点并下载区块链。
3. 另一个（矿工）节点连接到中心节点并下载区块链。
4. 钱包节点创建一笔交易。
5. 矿工节点接收交易，并将交易保存到内存池中。
6. 当内存池中有足够的交易时，矿工开始挖一个新块。
7. 当挖出一个新块后，将其发送到中心节点。
8. 钱包节点与中心节点进行同步。
9. 钱包节点的用户检查他们的支付是否成功。


##### 新节点的启动流程
> verzion消息用于找到一个更长的区块链
1. 当一个新的节点开始运行时，它会从一个 DNS 种子获取几个节点，给它们发送 verzion 消息
2. 一个节点接收到 verzion 消息，然后节点将从消息中提取的 BestHeight 与自身进行比较。如果自身节点的区块链更长，它会回复 version 消息；否则，它会发送 getblocks 消息。
3. getblocks 消息 -- 用于“给我看一下你有什么区块”
4. inv 消息 -- 用于 向其他节点展示当前节点有什么块和交易，不会包含完整的区块链和交易，仅仅是哈希而已
5. getdata 消息 -- 在 inv 消息发送时，检查是否在内存池中已经有了这个哈希，如果没有，发送 getdata 消息获取块（sendBlock）或获取交易（sendTx）
6. block 和 tx 用于实际完成数据的转移。
   1. 当接收到一个新块时，我们把它放到区块链里面。如果还有更多的区块需要下载，我们继续从上一个下载的块的那个节点继续请求。当最后把所有块都下载完后，对 UTXO 集进行重新索引。
   2. 当收到 tx 消息时，首先要做的事情是将新交易放到内存池中（再次提醒，在将交易放到内存池之前，必要对其进行验证）。之后，检查当前节点是否是中心节点（在我们的实现中，中心节点并不会挖矿。它只会将新的交易推送给网络中的其他节点）。如果是矿工节点，矿工节点的内存池中有两笔或更多的交易时，开始挖矿，添加区块。当块被挖出来以后，UTXO 集会被重新索引。
   3. 当一笔交易被挖出来以后，就会被从内存池中移除。当前节点所连接到的所有其他节点，接收带有新块哈希的 inv 消息。在处理完消息后，它们可以对块进行请求。